<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=Generator content="Microsoft Word 11 (filtered)">
<title>Использованные материалы:</title>

<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:"\@MS Mincho";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
h1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:Arial;}
h2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:Arial;
	font-style:italic;}
h3
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	page-break-after:avoid;
	font-size:13.0pt;
	font-family:Arial;}
h4
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Times New Roman";}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:24.0pt;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin:0cm;
	margin-bottom:.0001pt;
	text-indent:18.0pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Courier New";}
p.a, li.a, div.a
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Courier New";}
span.2
	{font-family:Arial;
	font-weight:bold;
	font-style:italic;}
p.1, li.1, div.1
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:16.0pt;
	font-family:Arial;
	font-weight:bold;}
@page Section1
	{size:841.9pt 595.3pt;
	margin:57.55pt 2.0cm 57.55pt 2.0cm;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=RU link=blue vlink=purple>

<div class=Section1>

<p class=MsoPlainText>Использованные материалы<span lang=EN-US>:</span></p>

<p class=MsoPlainText><span lang=EN-US>Common LISP Hints, Geoffrey J. Gordon, 
Friday, February 5, 1993</span></p>

<p class=MsoPlainText><span lang=EN-US>Modified by Bruno Haible,
&lt;haible@ma2s2.mathematik.uni-karlsruhe.de&gt;</span></p>

<p class=MsoPlainText><span lang=EN-US>&nbsp;</span></p>

<p class=1><span lang=EN-US>Введение в Common Lisp для профессионалов
Delphi/SQL</span></p>

<p class=MsoNormal>Цель данного документа – дать направления поиска информации
и указать эффективные подходы к работе для профессиональных разработчиков,
начинающих работу с <span lang=EN-US>Common</span><span lang=EN-US> </span><span
lang=EN-US>Lisp</span>. Рассмотрена версия <span lang=EN-US>Lispworks</span>,
при этом не различаются возможности стандарта и расширения <span lang=EN-US>Lispworks</span>.
Мои расширения выделены <span style='color:blue'>синим цветом</span>. <span
style='color:red'>Красным</span> цветом выделены понятия, которые обязательно
знать наизусть. Данный документ написан в меру знаний и отражает личные
предпочтения автора. </p>

<p class=MsoNormal>&nbsp;</p>

<p class=1><span lang=EN-US>Содержание</span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240520">Справочные
материалы и книги</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240521">Обозначения</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240522">Отличительные
особенности лиспа (по сравнению с Дельфи)</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240523">Сборка
мусора</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240524">Динамическая
разработка</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240525">Читатель/писатель</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240526">Макросы</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240527">Скажите,
девушка, где я?</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240528">Отладчик
очень близко</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240529">Недопечатанные
формы</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240530">Списки.
Квазицитирование</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240531">Вид списка
на печати и в памяти</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240532">Исходный
текст программы – это списки</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240533">Как создать
список</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240534">Присваивание
и переменные</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240535"><span
lang=EN-US>setf</span><span lang=EN-US> </span>и <span lang=EN-US>place</span></a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240536">Локальные
переменные</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240537">Глобальные
(специальные) переменные</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240538">Замыкания</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240539">Управляющие
конструкции</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240540">Организация
проекта. Файлы, пакеты, <span lang=EN-US>eval</span>-<span lang=EN-US>when</span>,
#., <span lang=EN-US>asdf</span>-системы, динамическая разработка</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240541">Определения
понятий</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240542">Таблица
аналогий</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240543">Что должно
входить в файл *.<span lang=EN-US>lisp</span></a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240544">Динамическая
разработка, основные сценарии</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240545">Работа в <span
lang=EN-US>listener (REPL)</span></a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240546">Разработка
по одной форме в файле</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240547">Перекомпиляция
файла целиком</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240548">Подводные
камни динамической разработки и как их обойти</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240549">Встроенные
типы данных: символы, списки, массивы, хеш-таблицы</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240550">Полиморфные
(родовые) функции, структуры и классы</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240551">Родовые
функции</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240552">Основные
методы с одним типизированным параметром</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240553">Методы со
спецификатором <span lang=EN-US>eql</span></a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240554">Методы<span
lang=EN-US> before, after, around</span></a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240555">Ложка дёгтя</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240556">Структуры</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240557">Конструктор</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240558">Деструктор</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240559">Ложка дёгтя</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240560">Классы</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240561">Изучение
исходного текста</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240562">Отладка</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240563">Виды
интерактивных отладочных режимов</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240564">Изучение
состояния программы</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240565">Настройка
отображения кадров стека</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240566">Инспектор</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240567">Листенер во
время отладки</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240568">Разновидности
ошибок и их локализация</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240569">Ошибки
чтения</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240570">Ошибки
компиляции</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240571">Ошибки
загрузки</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240572">Трассировка</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240573">Остановы и
пошаговое исполнение</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240574"><span
lang=EN-US>Assert</span>, <span lang=EN-US>with</span>-<span lang=EN-US>the</span>1</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240575"><span
lang=EN-US>Unit</span>-тестирование</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240576">Профайлер</a></span></p>

<p class=MsoToc1><span class=MsoHyperlink><a href="#_Toc345240577"><span
lang=EN-US>eval</span> и макросы</a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240578"><span
lang=EN-US>Eval</span></a></span></p>

<p class=MsoToc2><span class=MsoHyperlink><a href="#_Toc345240579">Макросы</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240580">Преимущества</a></span></p>

<p class=MsoToc3><span class=MsoHyperlink><a href="#_Toc345240581">Недостатки</a></span></p>

<p class=MsoNormal>&nbsp;</p>

<h1><a name="_Toc345240520">Справочные материалы и книги</a></h1>

<p class=MsoPlainText><span lang=EN-US><a
href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html">Guy L. Steele Jr. _<b>Common
LISP: the Language</b>_. Digital Press<span lang=RU>. 1984.</span></a></span></p>

<p class=MsoPlainText>Устаревший стандарт <span lang=EN-US>Common</span><span
lang=EN-US> </span><span lang=EN-US>Lisp</span>, но в удобочитаемой форме.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><b><span lang=EN-US><a
href="http://www.lispworks.com/documentation/lw50/CLHS/Front/">Common Lisp
Hyperspec<span style='font-weight:normal'> – </span><span lang=RU
style='font-weight:normal'>стандарт</span><span style='font-weight:normal'>
Common Lisp</span></a></span></b><span lang=EN-US> </span></p>

<p class=MsoPlainText>Обычно статьи из <span lang=EN-US>Hyperspec</span>
доступны в <span lang=EN-US>IDE</span> по нажатию горячей клавиши на имени
функции</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><a href="http://lisper.ru/pcl/">Книга «<b><span
lang=EN-US>Practical</span><span lang=EN-US> </span></b><b><span lang=EN-US>Common</span><span
lang=EN-US> </span></b><b><span lang=EN-US>Lisp</span></b>» в Русском переводе</a>
</p>

<p class=MsoPlainText>Хорошее практическое введение (более 400 страниц)</p>

<h1><a name="_Toc345240521">Обозначения</a></h1>

<p class=MsoNormal>Красным цветом обозначены понятия, смысл которых нужно знать
наизусть. </p>

<h1><a name="_Toc345240522">Отличительные особенности лиспа (по сравнению с
Дельфи)</a></h1>

<h2><a name="_Toc345240523">Сборка мусора</a></h2>

<p class=MsoBodyTextIndent>В лиспе реализована сборка мусора. Любой объект, на
который нет ссылок с других объектов, считается мусором (в т.ч. объект с
кольцевыми ссылками внутри себя). Периодически выполнение останавливается и
запускается сборка мусора, в ходе которой ненужные объекты уничтожаются и их
память освобождается. Возможны слабые ссылки, которые не препятствуют
уничтожению объекта, на который ссылаются (после сборки мусора эти ссылки
становятся пустыми), а также финализаторы (специальные функции, которые
вызываются над объектом, который вот-вот будет уничтожен сборщиком мусора).</p>

<h2><a name="_Toc345240524">Динамическая разработка</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>Динамическая разработка –
ключевое преимущество лиспа, которое очень помогает в разработке. Как правило,
Лисп позволяет менять программу без её перезапуска, в этом он подобен <span
lang=EN-US>SQL</span>. </p>

<p class=MsoNormal><span lang=EN-US style='color:red'>defclass</span><span
lang=EN-US> </span>работает аналогично<span lang=EN-US> CREATE TABLE/ALTER
TABLE. </span>Он позволяет добавить поля в класс или удалить их, с обновлением
уже существующих экземпляров.</p>

<p class=MsoNormal><span lang=EN-US style='color:red'>defstruct</span><span
lang=EN-US style='color:red'> </span>переопределяет структуру, но при этом уже
существующие экземпляры становятся устарвешими (<span lang=EN-US>obsolete</span>)
и попытка обращения к ним вызывает ошибку. </p>

<p class=MsoNormal><span lang=EN-US style='color:red'>defun,</span><span
lang=EN-US> <span style='color:red'>defgeneric </span></span><span
style='color:red'>и</span><span lang=EN-US style='color:red'> defmethod </span>работают
аналогично<span lang=EN-US> CREATE OR ALTER PROCEDURE, </span>причём можно менять
набор параметров<span lang=EN-US>. </span>Если функция в данный момент выполняется,
будет продолжать выполняться старое тело. Независимо от этого, все новые входы
в данную функцию (в т.ч. рекурсивно из уже выполняющегося старого тела) будут
использовать новое тело. В отладчике в некоторых случаях можно перезапустить
уже выполняющуюся функцию, при этом будет вызвано новое тело с теми же
параметрами. </p>

<p class=MsoNormal style='text-indent:18.0pt'>Также можно динамически
создавать/менять пространства имён (<span style='color:red'>пакеты</span>) <span
lang=EN-US>defpackage</span>, уничтожать их (<span lang=EN-US>delete</span>-<span
lang=EN-US>package</span>), включать и исключать идентификатор (<span
style='color:red'>символ</span>) в/из пространства имён. </p>

<p class=MsoNormal style='text-indent:18.0pt'>Возможности динамического
изменения программы могут быть ограничены при сборке с оптимизациями.</p>

<p class=MsoNormal style='text-indent:18.0pt'>Также в Лиспе есть <span
lang=EN-US style='color:red'>listener</span>, который по своим возможностям
аналогичен интерактивному <span lang=EN-US>SQL</span>. <span lang=EN-US
style='color:red'>listener</span> позволяет немедленно выполнять вычисления, не
проходя цикл написания, сборки и запуска приложения. В отладчике, <span
lang=EN-US style='color:red'>listener</span><span lang=EN-US style='color:red'>
</span>позволяет работать со значениями локальных переменных на разных уровнях
стека. Это очень удобно для разработки, тестирования и отладке программы –
вместо запуска всей программы удобно запускать её отдельные функции. </p>

<h2><a name="_Toc345240525">Читатель/писатель</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>Читатель (начинка функции <span
lang=EN-US style='color:red'>read</span>) – это парсер. Другие примеры парсеров
– парсеры <span lang=EN-US>XML</span>, <span lang=EN-US>JSON</span>, <span
lang=EN-US>dfm</span>. Также существует парсер <span lang=EN-US>Object</span><span
lang=EN-US> </span><span lang=EN-US>Pascal</span> в <span lang=EN-US>Delphi</span>,
который строит из текста дерево разбора. В <span lang=EN-US>Delphi</span> это
дерево недоступно для пользователя, оно используется только внутри компилятора
для генерации машинного кода. В Лиспе дерево, получающееся в результате работы
парсера, доступно пользователю. В этом смысле читатель Лиспа больше похож на
парсер <span lang=EN-US>dfm</span>, <span lang=EN-US>XML</span> или <span
lang=EN-US>JSON</span>, который разбирает данные, а не код. Особенности работы
читателя:</p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'>-<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>форматом ввода являются <span lang=EN-US>S</span>-выражения (скобки,
точки, атомы и др.). Скобки и точки отвечают за группировку данных в деревья.
Атомы являются листьями деревьев.</p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'>-<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>идентификаторы программы являются атомами. При их считывании они
отражаются как специальные структуры данных типа <span style='color:red'>символ</span>.
Когда идентификатор встречается в программе первый раз за время жизни
программы, создаётся символ с таким именем. При последующих чтениях того же
идентификатора в дерево вставляется ссылка на уже имеющийся символ. </p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'>-<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>также можно задать формат для ввода объектов произвольных типов.</p>

<p class=MsoNormal style='text-indent:18.0pt'>Читатель может использоваться как
для ввода исходного текста программы, так и для ввода произвольных данных из
текстового формата. Разница – не в структуре этих данных, а в том, что с ними в
дальнейшем делается. Поэтому говорят, что в Лиспе код=данные, что также
обозначается словом <i><span lang=EN-US>homoiconicity</span></i>.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal style='text-indent:18.0pt'>Писатель – это начинка функции <span
lang=EN-US style='color:red'>print</span>. Можно считать функцию <span
lang=EN-US>print</span> расширяемым аналогом функции <span lang=EN-US>write</span>
из Дельфи.</p>

<p class=MsoNormal style='text-indent:18.0pt'>В <span lang=EN-US>Delphi</span>,
с помощью <span lang=EN-US>write</span> можно выводить примитивные типы
(строки, числа). Чтобы изобразить более сложный объект в виде текста, нужно
писать специальный код, выводящий данные в строки и передающий <span
lang=EN-US>write</span> эти строки. Например, нельзя вывести <span lang=EN-US>TList</span>
с помощью <span lang=EN-US>write</span>. В Лиспе, строки, числа, символы,
списки, массивы, структуры, <span style='color:blue'>хеш-таблицы</span> имеют
формат вывода по умолчанию, при котором выводится содержимое этих объектов. Для
классов также придётся писать метод <span lang=EN-US>print</span>-<span
lang=EN-US>object</span>, но, если в <span lang=EN-US>Delphi</span> пришлось бы
писать <span lang=EN-US>write</span>(<span lang=EN-US>printObject</span>(<span
lang=EN-US>myObj</span>)), то в лиспе пишется просто (<span lang=EN-US>print</span><span
lang=EN-US> </span><span lang=EN-US>my</span>-<span lang=EN-US>obj</span>).</p>

<p class=MsoNormal style='text-indent:18.0pt'>Читатель и писатель согласованы.
Во многих случаях, если писатель что-то написал, то читатель может прочитать
написанное и построить &quot;такой же&quot; объект, либо вернуть ссылку на тот
же самый объект, который ранее был напечатан. Некоторые объекты нельзя читать
по тем или иным причинам, они представляются на печати с помощью #&lt;какой-то
текст&gt;. При попытке читателя прочитать это представление возникает ошибка.
Также писатель может не печатать слишком длинные или глубоко вложенные списки
(это настраивается), тогда список будет напечатан с многоточием и при попытке
его чтения также возникнет ошибка. </p>

<p class=MsoNormal style='text-indent:18.0pt'>&nbsp;</p>

<p class=MsoNormal style='text-indent:18.0pt'>Возможен ввод-вывод данных с
циклическими ссылками.</p>

<h2><a name="_Toc345240526">Макросы</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>В <span lang=EN-US>Delphi</span>
существуют макросы {$define}, {$ifdef}, {$include}, которые позволяют проводить
простейшие манипуляции над исходным текстом во время его чтения. В С есть более
мощный макропроцессор #<span lang=EN-US>define</span>, в котором есть
возможности конкатенации текста, вычисления константных выражений и вызова
одних макросов из других. </p>

<p class=MsoNormal style='text-indent:18.0pt'>Самый мощный макропроцессор – в <span
lang=EN-US>bat</span> –файлах, т.к. в <span lang=EN-US>bat</span>-файле можно
составлять команду во время выполнения с помощью подстановок переменных (%<span
lang=EN-US>someVariable</span>%) и тут же выполнять её. </p>

<p class=MsoBodyTextIndent>В лиспе есть схожие возможности, а именно:</p>

<p class=MsoNormal style='text-indent:18.0pt'>После построения читателем
дерева, во время его обработки компилятором, ищутся имена <span
style='color:red'>макросов. </span>Макрос – специальная функция, работающая на
этапе компиляции. Она получает на вход дерево грамматического разбора,
выполняет над ним <i>произвольные</i> вычисления и возвращает другое дерево,
которое подставляется вместо исходного. При этом обычно используется <span
style='color:red'>квазицитирование </span>– способ построения деревьев по
шаблону. </p>

<h1><a name="_Toc345240527">Скажите, девушка, где я?</a></h1>

<p class=MsoNormal>При работе в <span lang=EN-US style='color:red'>listener</span>
легко сбиться с толку. Чтобы это случалось не слишком часто, нужно понимать следующие
вещи:</p>

<h2><a name="_Toc345240528">Отладчик очень близко</a></h2>

<p class=MsoNormal>Обычно подсказка <span lang=EN-US>listener</span> выглядит
как <span lang=EN-US>CL</span>-<span lang=EN-US>USER</span><span lang=EN-US> </span><span
lang=EN-US>NN</span> &gt; , где <span lang=EN-US>NN</span> – возрастающий
порядковый номер, который увеличивается на 1 после каждого ввода. Попробуем
ввести в <span lang=EN-US>listener</span> выражение (/ 1 0). Мы увидим
следующее:</p>

<p class=MsoNormal><span lang=EN-US>Error: Division-by-zero caused by / of (1
0).</span></p>

<p class=MsoNormal>...</p>

<p class=MsoNormal><span lang=EN-US>CL-USER NN : 1 &gt; </span></p>

<p class=MsoNormal>Суффикс : 1 говорит, что мы находимся в отладчике. Об этом
же говорит то, что на панели инструментов стала доступна кнопка с изображением
жука (бага). Нажав на неё, мы попадём в графический отладчик, в нём увидим стек
и т.д. Данное окно графического отладчика будет связано с окном <span
lang=EN-US>listener</span>, хотя это не видно. </p>

<p class=MsoNormal>Подсказка отладчика мало чем отличается от обычной подсказки
листенера не только по виду, но и по возможностям: в ней также можно проводить
произвольные вычисления, как и в обычной подсказке. Это очень хорошо (в <span
lang=EN-US>Delphi</span> так нельзя), но это может сильно сбивать с толку.</p>

<p class=MsoNormal>Попробуем теперь снова ввести (/ 1 0) в окне <span
lang=EN-US>listener</span>. Подсказка изменится:</p>

<p class=MsoNormal><span lang=EN-US>CL-USER NN : 2 &gt; </span></p>

<p class=MsoNormal>двойка говорит о том, что мы находимся в отладчике
рекурсивно, и уровень вложенности отладчиков равен двум. В окне графического
отладчика можно видеть, что функции / и <span lang=EN-US>error</span>
присутствуют в стеке дважды. </p>

<p class=MsoNormal>Теперь можно (в окне <span lang=EN-US>listener</span>)
набрать :<span lang=EN-US>a</span> и &lt;<span lang=EN-US>Enter</span>&gt; (или
<span lang=EN-US style='color:blue'>Ctrl</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>D</span>) - это примерно то же, что бросить
исключение <span lang=EN-US>EAbort</span>. Выпадем обратно в первый уровень
отладчика. Набрав :<span lang=EN-US>a</span> &lt;<span lang=EN-US>Enter</span>&gt;
ещё раз, вернёмся в нормальное состояние интерпретатора. Во время :<span
lang=EN-US>a</span> защитный код (аналог <span lang=EN-US>finally</span>)
выполняется, как и при обычном выполнении программы. ПОэтому, если мы
&quot;упали&quot; в отладчик в каком-то месте, выход из отладчика по :<span
lang=EN-US>a</span> является безопасным. </p>

<p class=MsoNormal>Данный отладчик,  хоть и не даёт возможности пошагового
исполнения (эта возможность предоставляется отдельным средством – степпером),
обладает другими очень полезными возможностями, во многом мы терпим лисп ради
них. Помимо возможности вычисления произвольных выражений в контексте
программы, он во многих случаях позволяет перезапустить какой-то кадр стека с
новым определением функции, которая вызвана в этом кадре. Это возможно, когда
функция имеет только обязательные параметры и не имеет необязательных. </p>

<h2><a name="_Toc345240529">Недопечатанные формы</a></h2>

<p class=MsoNormal>В листенере можно вводить многострочные команды. Команда
считается завершённой, когда вы ввели полную форму, в которой все скобки,
кавычки и т.п. закрыты, и после этого нажали <span lang=EN-US>Enter</span>. </p>

<p class=MsoNormal>Строковый литерал (строка в кавычках) также может быть
многострочной. Как понять, находится ли листенер в состоянии чтения команды или
вычисления? После запуска команды на выполнение её текст окрашивается в красный
цвет. Если есть сомнения, всегда можно нажать <span lang=EN-US>Ctrl</span>-<span
lang=EN-US>Break</span><span lang=EN-US> </span>(или на вот такой кирпич <img
border=0 width=43 height=57 src="lisp-tutorial.files/image001.jpg">) и
посмотреть на стек. Также есть диспетчер процессов, <span lang=EN-US>works</span>/<span
lang=EN-US>tools</span>/<span lang=EN-US>process</span><span lang=EN-US> </span><span
lang=EN-US>browser</span>, но не забудьте после открытия нажать <span
lang=EN-US>F</span>5 для обновления состояния. </p>

<p class=MsoNormal>Другие сведения о локализации ошибок см. в разделе об
отладке. </p>

<h1><a name="_Toc345240530">Списки. Квазицитирование</a></h1>

<h2><a name="_Toc345240531">Вид списка на печати и в памяти</a></h2>

<p class=MsoBodyTextIndent>Список выглядит в тексте так:</p>

<p class=a>( элемент1 элемент2 ... элемент<span lang=EN-US>N</span> )</p>

<p class=MsoBodyTextIndent>Внутри список (1 2 3 4) представляет из себя
кособокое дерево объектов типа <span lang=EN-US>cons</span>: (картинка отсюда <a
href="http://eli.thegreenplace.net/2007/08/10/sicp-section-221/">http://eli.thegreenplace.net/2007/08/10/sicp-section-221/</a></p>

<p class=MsoBodyTextIndent><img border=0 width=217 height=88
src="lisp-tutorial.files/image002.jpg"></p>

<p class=MsoBodyTextIndent>Т.е, наиболее быстрые операции над списком – это
операции над его первым элементом, а доступ к произвольному элементу имеет
сложность <span lang=EN-US>O</span>(<span lang=EN-US>length</span>(<span
lang=EN-US>x</span>)) Разные списки могут иметь общий хвост.</p>

<h2><a name="_Toc345240532">Исходный текст программы – это списки</a></h2>

<p class=MsoBodyTextIndent>Исходный текст по большей части представляет из себя
списки, поэтому очень важно уметь работать с ними в редакторе. Над списками
доступны команды: </p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'><span
style='color:red'>-<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='color:red'>переход от закрывающей к открывающей
скобке и обратно</span></p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'>-<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='color:red'>удаление списка до или после курсора в буфер
обмена</span> (<span lang=EN-US>kill</span>)</p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'>-<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='color:red'>переход на следующий/предыдущий список</span> и
на список верхнего уровня</p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'>-<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>перестановка двух списков перед курсором</p>

<p class=MsoNormal style='text-indent:18.0pt'>Для изучения этих команд можно
открыть любой файл с исходным текстом в редакторе.   </p>

<p class=MsoNormal style='text-indent:18.0pt'>Также можно отметить, что
редактор подсвечивает парную скобку и раскрашивает скобки в разные цвета. </p>

<p class=MsoNormal style='text-indent:18.0pt'>Поскольку синтаксис лиспа
неудобный, при работе важную роль играют отступы. <span lang=EN-US>IDE</span>
автоматически выставляет отступы, для этого после нажатия <span lang=EN-US>Enter</span>
при начале новой строки нужно также нажимать <span lang=EN-US>Tab</span>. Также
есть команда <span lang=EN-US>Alt</span>-. <span lang=EN-US>indent</span><span
lang=EN-US> </span><span lang=EN-US>form</span>, которая выравнивает целое
определение (нужно стоять в начале определения). </p>

<h2><a name="_Toc345240533">Как создать список</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>Чтобы создать новый список в <span
lang=EN-US style='color:red'>listener</span>-е, можно написать:</p>

<p class=a><span lang=EN-US>&gt; '(a &quot;b&quot; a 123)</span></p>

<p class=a><span lang=EN-US>(a &quot;b&quot; a 123) ; это напечатает листенер</span></p>

<p class=MsoNormal style='text-indent:18.0pt'>Здесь мы построили <span
style='color:red'>список</span> из четырёх элементов. Первый и третий элементы
идентичны – это символ с именем &quot;A&quot;. Второй элемент – строка &quot;<span
lang=EN-US>b</span>&quot;, четвёртый – число 123. Лисп печатает результат нашей
работы. Мы использовали одиночную кавычку - &quot;цитирование&quot;, чтобы
листенер не воспринял нашу команду как вызов функции <span lang=EN-US>a</span>.
Через некоторое время наш список может стать мусором, т.к. мы его ничему не
присвоили, а символ с именем &quot;А&quot; останется, т.к. при чтении он
автоматически попал в текущее пространство имён.</p>

<p class=MsoNormal style='text-indent:18.0pt'>Двухуровневый список можно
построить так:</p>

<p class=a><span lang=EN-US>&gt; '(a (a)) </span></p>

<p class=MsoNormal style='text-indent:18.0pt'>Он будет содержать две ссылки на
тот же самый символ с именем &quot;<span lang=EN-US>A</span>&quot;.</p>

<p class=MsoNormal style='text-indent:18.0pt'>Здесь второй элемент списка –
список из одного элемента (символа с именем &quot;<span lang=EN-US>A</span>&quot;).
</p>

<p class=MsoNormal style='text-indent:18.0pt'>Другой способ построения такого
же списка:</p>

<p class=a><span lang=EN-US>&gt; (list 'a &quot;b&quot; 'a (+ 120 3))</span></p>

<p class=MsoNormal style='text-indent:18.0pt'>Здесь для построения используется
функция <span lang=EN-US>list</span>. Эта функция вычисляет все свои аргументы
и составляет из них свежий список. Последний аргумент – это вычисление
выражения 120+3=123. </p>

<p class=MsoNormal style='text-indent:18.0pt'>Третий способ:</p>

<p class=a>&gt; `(<span lang=EN-US>a</span> &quot;<span lang=EN-US>b</span>&quot;
<span lang=EN-US>a</span> ,<b>(+ 120 3)</b>) </p>

<p class=MsoBodyTextIndent>Здесь применено квазицитирование. Апостроф означает,
что следующее за ним лисп-выражение – это шаблон. Данные в шаблоне не
вычисляются. Но если в шаблоне встречается запятая или &quot;,@&quot; , то
следующее выражение – подставляемое, оно вычисляется. Данная конструкция чем-то
аналогична функциям форматного вывода и её можно смоделировать в Дельфи так:</p>

<p class=MsoNormal style='text-indent:18.0pt'><span lang=EN-US>format('(a,''b'',a,%d)',[120+3])</span></p>

<p class=MsoNormal style='text-indent:18.0pt'>Отличие состоит в том, что в
Дельфи эта конструкция работает со строками, а в Лиспе – с деревьями. </p>

<p class=MsoNormal style='text-indent:18.0pt'>Шаблоны и обычные цитаты могут
быть вложенными и могут быть вложены друг в друга.</p>

<h1><a name="_Toc345240534">Присваивание и переменные</a></h1>

<h2><a name="_Toc345240535"><span lang=EN-US>setf</span></a> и <span
lang=EN-US>place</span></h2>

<p class=MsoNormal><span lang=EN-US>setf</span> – это присваивание, оно вполне
аналогично := в <span lang=EN-US>Delphi</span>. То, чему можно присваивать,
называется <span style='color:red'>место</span> (<span lang=EN-US
style='color:red'>place</span>). В частности, местами являются имена
переменных, элементы списков и массивов, подстроки строк, значения хеш-таблиц,
соответствующие определённому ключу и т.п. Можно определить новые виды мест.
Общий вид присваивания: </p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span style='font-family:"Courier New"'>(</span><span
lang=EN-US style='font-family:"Courier New"'>setf</span><span style='font-family:
"Courier New"'> место1 значение1 ... место</span><span lang=EN-US
style='font-family:"Courier New"'>N</span><span style='font-family:"Courier New"'>
значение</span><span lang=EN-US style='font-family:"Courier New"'>N</span><span
style='font-family:"Courier New"'>)</span></p>

<h2><a name="_Toc345240536">Локальные переменные</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>Локальные переменные полностью
аналогичны локальным переменным <span lang=EN-US>Delphi</span>, но есть
следующие отличия:</p>

<p class=MsoNormal style='text-indent:18.0pt'>В Дельфи переменные определяются
до слова <span lang=EN-US>begin</span> с помощью слова <span lang=EN-US>var</span>,
в Лиспе они определяются внутри тела функции с помощью разнообразных
конструкций (<span lang=EN-US>let</span>, <span lang=EN-US>destructuring</span>-<span
lang=EN-US>bind</span>, <span lang=EN-US>multiple</span>-<span lang=EN-US>value</span>-<span
lang=EN-US>bind</span><span lang=EN-US> </span><span style='color:blue'>(</span><span
lang=EN-US style='color:blue'>mlvl</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>bind</span><span style='color:blue'>)</span>, <span
lang=EN-US>with</span>-<span lang=EN-US>open</span>-<span lang=EN-US>file</span>
и т.п.) и их область действия – до закрывающей скобки. </p>

<h2><a name="_Toc345240537">Глобальные (специальные) переменные</a></h2>

<p class=MsoBodyTextIndent>В Лиспе глобальные переменные очень полезны и они
интенсивно применяются, например, для сбора данных при рекурсивном обходе
какого-либо дерева или для хранения разного рода режимов работы.</p>

<p class=MsoBodyTextIndent>Основная особенность работы с глобальными
переменными: когда такой переменной делается <span lang=EN-US>let</span>, её
старое значение запоминается и временно заменяется на новое. После выхода из
области действия <span lang=EN-US>let</span>, старое значение
восстанавливается. Пример работы в однопоточном приложении:</p>

<p class=MsoBodyTextIndent>&nbsp;</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(defparameter *glob* </span><span
  style='font-size:10.0pt'>1</span><span lang=EN-US style='font-size:10.0pt'>)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'> </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>(</span><span lang=EN-US
  style='font-size:10.0pt;color:red'>progn</span><span lang=EN-US
  style='font-size:10.0pt;color:red'> </span><span style='font-size:10.0pt'>;
  составной оператор, то же, что </span><span lang=EN-US style='font-size:10.0pt'>begin</span><span
  style='font-size:10.0pt'>..</span><span lang=EN-US style='font-size:10.0pt'>end</span><span
  style='font-size:10.0pt'>;<span style='color:red'> </span></span></p>
  <p class=a><span style='font-size:10.0pt'>   </span><span lang=EN-US
  style='font-size:10.0pt'>(let ((*glob* 2))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>      (format t
  &quot;связана в ~S&quot; *glob*)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>      (setf *glob* 3)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>      (format t
  &quot;после setf ~S&quot; *glob*)</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>   )</span></p>
  <p class=a><span style='font-size:10.0pt'>   (</span><span lang=EN-US
  style='font-size:10.0pt'>format</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span lang=EN-US style='font-size:10.0pt'>t</span><span
  style='font-size:10.0pt'> &quot;после выхода из </span><span lang=EN-US
  style='font-size:10.0pt'>let</span><span style='font-size:10.0pt'> ~</span><span
  lang=EN-US style='font-size:10.0pt'>S</span><span style='font-size:10.0pt'>&quot;
  *</span><span lang=EN-US style='font-size:10.0pt'>glob</span><span
  style='font-size:10.0pt'>*)</span></p>
  <p class=a>)</p>
  <p class=a>&nbsp;</p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>var</span><span
  lang=EN-US style='font-size:10.0pt'> </span><span lang=EN-US
  style='font-size:10.0pt'>glob</span><span style='font-size:10.0pt'>:</span><span
  lang=EN-US style='font-size:10.0pt'>integer</span><span style='font-size:
  10.0pt'>=1; </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>var saveGlob:integer;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>begin</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>try </span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  saveGlob:=glob;
  glob:=2;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  writeln(format('</span><span
  style='font-size:10.0pt'>связана</span><span style='font-size:10.0pt'> </span><span
  style='font-size:10.0pt'>в</span><span lang=EN-US style='font-size:10.0pt'>
  %d',[glob]));</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  glob:=3;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  writeln(format('</span><span
  style='font-size:10.0pt'>после</span><span lang=EN-US style='font-size:10.0pt'>
  := %d',[glob]));</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>finally</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  glob:=saveGlob;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  end;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>writeln</span><span
  style='font-size:10.0pt'>(</span><span lang=EN-US style='font-size:10.0pt'>format</span><span
  style='font-size:10.0pt'>('после выхода из </span><span lang=EN-US
  style='font-size:10.0pt'>let</span><span style='font-size:10.0pt'>'</span><span
  lang=EN-US style='font-size:10.0pt'>,[glob]);</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>end.</span></p>
  </td>
 </tr>
</table>

<p class=MsoBodyTextIndent>&nbsp;</p>

<p class=MsoBodyTextIndent>Если используемая в функции переменная не определена
в ней, компилятор предполагает, что она глобальна и выдаёт предупреждение. </p>

<p class=MsoBodyTextIndent>Однако, если вы связываете имя глобальной
переменной, думая, что она локальная, это может вызвать проблемы. Поэтому нужно
следовать такому безопасному сценарию работы с глобальными переменными:</p>

<p class=MsoBodyTextIndent>1. переменная создаётся с помощью <span lang=EN-US
style='color:red'>defparameter</span> (или с помощью <span lang=EN-US
style='color:red'>defvar</span>, если переменная должна быть инициализирована
только один раз за жизнь программы)</p>

<p class=MsoBodyTextIndent>2. Имя переменной должно быть окружено звёздочками,
*<span lang=EN-US>my</span>-<span lang=EN-US>variable</span>*.</p>

<p class=MsoBodyTextIndent>3. Приложение должно собираться без предупреждений
&quot;variable ... <span lang=EN-US>assumed</span><span lang=EN-US> </span><span
lang=EN-US>special</span>&quot;. В частности, глобальная переменная должна быть
объявлена по течению процесса сборки до любого её использования. </p>

<p class=MsoBodyTextIndent>4. В многонитевом приложении, в любой нити (потоке
исполнения, <span lang=EN-US>thread</span>, <span lang=EN-US>lightweight</span><span
lang=EN-US> </span><span lang=EN-US>process</span>), где переменная
используется, она должна быть связана до любого обращения к ней. Например,
можно связать её при входе в нить, с помощью <span lang=EN-US style='color:
red'>let</span>. Уже после этого можно читать и присваивать переменную. </p>

<h2><a name="_Toc345240538">Замыкания</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>Можно продлить жизнь локальной
переменной на неопределённое время, если &quot;замкнуть&quot; её с помощью
генератора функций <span lang=EN-US style='color:red'>lambda</span>. Например,
следующая функция показывает пример этого, с переводом на Дельфи:</p>

<p class=MsoNormal style='text-indent:18.0pt'>&nbsp;</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=475 valign=top style='width:356.4pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>(</span><span lang=EN-US
  style='font-size:10.0pt'>defun</span><span style='font-size:10.0pt'>
  создОбменныйПункт (начЗнач)</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>   (</span><span lang=EN-US
  style='font-size:10.0pt'>let</span><span style='font-size:10.0pt'> ((ячейка
  начЗнач))</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>       (</span><span lang=EN-US
  style='font-size:10.0pt'>lambda</span><span style='font-size:10.0pt'>
  (новЗнач) </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>           (</span><span
  lang=EN-US style='font-size:10.0pt'>let</span><span style='font-size:10.0pt'>
  ((результат ячейка))</span></p>
  <p class=a><span style='font-size:10.0pt'>              (</span><span
  lang=EN-US style='font-size:10.0pt'>setf</span><span style='font-size:10.0pt'>
  ячейка новЗнач)</span></p>
  <p class=a><span style='font-size:10.0pt'>              результат ; </span><span
  lang=EN-US style='font-size:10.0pt'>lambda</span><span style='font-size:10.0pt'>
  возвращает результат</span></p>
  <p class=a><span style='font-size:10.0pt'>           ) ; закрывается </span><span
  lang=EN-US style='font-size:10.0pt'>let</span></p>
  <p class=a><span style='font-size:10.0pt'>       ) ; закрывается </span><span
  lang=EN-US style='font-size:10.0pt'>lambda</span></p>
  <p class=a><span style='font-size:10.0pt'>   ) ; закрывается </span><span
  lang=EN-US style='font-size:10.0pt'>let</span><span style='font-size:10.0pt'> 
  </span></p>
  <p class=a><span style='font-size:10.0pt'>   ; </span><span lang=EN-US
  style='font-size:10.0pt'>defun</span><span style='font-size:10.0pt'> вернёт </span><span
  lang=EN-US style='font-size:10.0pt'>lambda</span><span style='font-size:10.0pt'>,
  т.е. свежую функцию</span></p>
  <p class=a><span style='font-size:10.0pt'>) </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&gt; (</span><span lang=EN-US
  style='font-size:10.0pt;color:red'>funcall</span><span style='font-size:10.0pt'>
  ; вызывает свой первый аргумент, </span></p>
  <p class=a><span style='font-size:10.0pt'>           ; который должен быть
  функцией </span></p>
  <p class=a><span style='font-size:10.0pt'>           ; и передаёт ей свои
  остальные параметры</span></p>
  <p class=a><span style='font-size:10.0pt'>      (создОбменныйПункт 4) ;
  вернётся свежая функция</span></p>
  <p class=a><span style='font-size:10.0pt'>      5)</span></p>
  <p class=a><span style='font-size:10.0pt'>4 ; в переменной ячейка теперь 5,
  но она стала мусором, </span></p>
  <p class=a><span style='font-size:10.0pt'>  ; т.к. мы не сохранили ссылку на
  возврат выражения</span></p>
  <p class=a><span style='font-size:10.0pt'>  ; (создОбменныйПункт 4)</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  </td>
  <td width=511 valign=top style='width:382.9pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>type</span><span
  style='font-size:10.0pt'> создОбменныйПунктЗамыкание1 = </span><span
  lang=EN-US style='font-size:10.0pt'>class</span><span style='font-size:10.0pt'>(</span><span
  lang=EN-US style='font-size:10.0pt'>TObject</span><span style='font-size:
  10.0pt'>)</span></p>
  <p class=a><span style='font-size:10.0pt'>  ячейка</span><span lang=EN-US
  style='font-size:10.0pt'> : variant;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  function lambda(</span><span
  style='font-size:10.0pt'>новЗнач</span><span lang=EN-US style='font-size:
  10.0pt'>:variant);</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>end;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>function </span><span
  style='font-size:10.0pt'>создОбменныйПункт</span><span lang=EN-US
  style='font-size:10.0pt'>(</span><span style='font-size:10.0pt'>начЗнач</span><span
  lang=EN-US style='font-size:10.0pt'>:variant)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    :</span><span
  style='font-size:10.0pt'>создОбменныйПунктЗамыкание</span><span lang=EN-US
  style='font-size:10.0pt'>1;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>begin</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>result:=</span><span
  style='font-size:10.0pt'>создОбменныйПунктЗамыкание</span><span lang=EN-US
  style='font-size:10.0pt'>1.create;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>result</span><span
  style='font-size:10.0pt'>.ячейка:=начальноеЗначение;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>end</span><span
  style='font-size:10.0pt'>;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>function</span><span
  style='font-size:10.0pt'> создОбменныйПунктЗамыкание1.</span><span
  lang=EN-US style='font-size:10.0pt'>lambda</span><span style='font-size:10.0pt'>(новЗнач:</span><span
  lang=EN-US style='font-size:10.0pt'>variant</span><span style='font-size:
  10.0pt'>);</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>begin</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>result:=</span><span
  style='font-size:10.0pt'>ячейка</span><span lang=EN-US style='font-size:10.0pt'>;</span></p>
  <p class=a><span style='font-size:10.0pt'>ячейка:=новЗнач;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>end</span><span
  style='font-size:10.0pt'>;</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>var</span><span
  lang=EN-US style='font-size:10.0pt'> </span><span lang=EN-US
  style='font-size:10.0pt'>arg</span><span style='font-size:10.0pt'>1:создОбменныйПунктЗамыкание1;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>begin</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>arg</span><span
  style='font-size:10.0pt'>1:=создОбменныйПункт(4);</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>arg</span><span
  style='font-size:10.0pt'>1.</span><span lang=EN-US style='font-size:10.0pt'>lambda</span><span
  style='font-size:10.0pt'>(5);</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>freeAndNil</span><span
  style='font-size:10.0pt'>(</span><span lang=EN-US style='font-size:10.0pt'>arg</span><span
  style='font-size:10.0pt'>1); // в лиспе это сделает сборщик мусора</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>end</span><span
  style='font-size:10.0pt'>.</span></p>
  </td>
 </tr>
</table>

<p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>

<p class=MsoNormal>При каждом вызове функции создатьОбменныйПункт будет создана
и возвращена пользователю новая анонимная функция. Эта функция будет не только
хранить значение переменной &quot;ячейка&quot;, но и позволит поменять это
значение.</p>

<p class=MsoNormal>&nbsp;</p>

<h1><a name="_Toc345240539">Управляющие конструкции</a></h1>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US>Delphi</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US>CL</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:8.0pt;font-family:"Courier New"'>IfThen(j=0,0,j+4);
  </span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(if (= j 0) 0 (+ 4 j))</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>if
  a=1 then </span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  writeln('</span><span style='font-size:10.0pt;font-family:"Courier New"'>один</span><span
  lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>')</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>else
  if a=2 then</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  writeln('</span><span style='font-size:10.0pt;font-family:"Courier New"'>два</span><span
  lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>')</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>else
  </span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  writeln('</span><span style='font-size:10.0pt;font-family:"Courier New"'>много</span><span
  lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>');</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>&nbsp;</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(cond</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  ((= a 1) </span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    (print &quot;</span><span
  style='font-size:10.0pt'>один</span><span lang=EN-US style='font-size:10.0pt'>&quot;))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  ((= a 2)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    (print &quot;</span><span
  style='font-size:10.0pt'>два</span><span lang=EN-US style='font-size:10.0pt'>&quot;))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (t</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>   (print &quot;</span><span
  style='font-size:10.0pt'>много</span><span lang=EN-US style='font-size:10.0pt'>&quot;)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>   )</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>for
  i:=0 to N-1 do</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  begin</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  if i=5 then continue;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  if i=7 then break;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  writeln(i);</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  end</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(dotimes (i N)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>   (when (= i 5) (go
  :continue))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>   (when (= i 7) (return
  nil))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>   (print i)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>   :continue)</span></p>
  <p class=a><span style='font-size:10.0pt'>ЛИБО </span></p>
  <p class=a><span style='font-size:10.0pt'>(</span><span lang=EN-US
  style='font-size:10.0pt;color:blue'>iter</span><span lang=EN-US
  style='font-size:10.0pt;color:blue'> </span><span style='font-size:10.0pt'>;
  мощнее, но хуже поддерживается отладчиком</span></p>
  <p class=a><span style='font-size:10.0pt'>  </span><span lang=EN-US
  style='font-size:10.0pt'>(:for i :from 0 :to (- N 1))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (:when (= i 5)
  (:next-iteration))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (:when (= i 7) (return
  nil))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  )</span></p>
  <p class=a><span style='font-size:10.0pt'>ЛИБО</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>while
  i&gt;j do</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  inc(i,-1);</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(loop</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (unless (&gt; i j) </span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>     (return nil))</span></p>
  <p class=a><span style='font-size:10.0pt'>  (</span><span lang=EN-US
  style='font-size:10.0pt'>incf</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span lang=EN-US style='font-size:10.0pt'>i</span><span
  style='font-size:10.0pt'> –1)</span></p>
  <p class=a><span style='font-size:10.0pt'>  )</span></p>
  <p class=a><span style='font-size:10.0pt'>ИЛИ </span></p>
  <p class=a><span style='font-size:10.0pt'>(</span><span lang=EN-US
  style='font-size:10.0pt;color:blue'>iter</span><span lang=EN-US
  style='font-size:10.0pt;color:blue'> </span><span style='font-size:10.0pt'>;
  мощнее, но хуже поддерживается отладчиком</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt;color:blue'>  </span><span
  lang=EN-US style='font-size:10.0pt'>(:while (&gt; i j))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (incf i –1)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  )</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>procedure
  outer;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  var v:variant;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  procedure inner;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  begin</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  v:=v+1;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  end</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>begin{procedure
  outer}</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>v:=0;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>inner;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>end;</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(defun outer ()</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt;color:blue'>  </span><span
  lang=EN-US style='font-size:10.0pt'>(let ((v 0))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    (flet ((inner ()</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>              (incf v)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>               ))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>       (inner)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>       )))</span></p>
  <p class=a><span style='font-size:10.0pt'>ЛИБО</span><span lang=EN-US
  style='font-size:10.0pt'> </span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(defun outer ()</span></p>
  <p class=a><span style='font-size:10.0pt'>  (</span><span lang=EN-US
  style='font-size:10.0pt;color:blue'>proga</span><span style='font-size:10.0pt'>
  ; нестандартно, эквивалентно предыдущему,</span></p>
  <p class=a><span style='font-size:10.0pt'>         ; но меньше скобок и хуже
  поддерживается отладч.</span></p>
  <p class=a><span style='font-size:10.0pt'>     (</span><span lang=EN-US
  style='font-size:10.0pt'>let</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span lang=EN-US style='font-size:10.0pt'>v</span><span
  style='font-size:10.0pt'> 0)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>     (flet inner ()</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>        (incf v))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>     (inner)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>     ))</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>     </span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>try</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  op1;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  op2;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>finally</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  op3;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  op4;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  end;</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(unwind-protect </span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (progn</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    op1</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    op2)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  op3</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  op4 </span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  )</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>try</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>&nbsp;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  op1; </span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  op2;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>except</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  on E1:class1 do</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  begin</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  writeln(E1.message);</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  op4;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  end</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  on E2:class2 do</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  begin</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  raise;</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>   
  end</span></p>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'> 
  end;</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>(handler-case</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (progn</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    op1</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    op2)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (class1 (e1)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    (princ e1)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    op4</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>    )</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>  (class2 (e2)</span></p>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>    (</span><span lang=EN-US
  style='font-size:10.0pt'>error</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span lang=EN-US style='font-size:10.0pt'>e</span><span
  style='font-size:10.0pt'>2)</span></p>
  <p class=a><span style='font-size:10.0pt'>    )</span></p>
  <p class=a><span style='font-size:10.0pt'>  ) ; </span><i><span
  style='font-size:6.0pt'>ну вот, заодно и сам узнал</span></i><span
  style='font-size:10.0pt'>   </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  </td>
 </tr>
</table>

<p class=MsoNormal>&nbsp;</p>

<h1><a name="_Toc345240540">Организация проекта. Файлы, пакеты, </a><span
lang=EN-US>eval</span>-<span lang=EN-US>when</span>, #., <span lang=EN-US>asdf</span>-системы,
динамическая разработка</h1>

<p class=MsoBodyTextIndent>Структура проекта и процесс загрузки приложения на
Лиспе гораздо сложнее, чем на Дельфи, поскольку:</p>

<p class=MsoBodyTextIndent>- в Дельфи мало что можно поменять во время
выполнения, а в Лиспе можно поменять почти всё</p>

<p class=MsoBodyTextIndent>- понятие модуля в Дельфи являются монолитными, а в
Лиспе оно разделено на несколько понятий</p>

<p class=MsoBodyTextIndent>- многое из того, что  в Дельфи делается автоматически,
в Лиспе нужно делать руками. </p>

<h2><a name="_Toc345240541">Определения понятий</a></h2>

<p class=MsoBodyTextIndent>Файл *.<span lang=EN-US>lisp</span><span lang=EN-US>
</span>– аналог *.<span lang=EN-US>pas</span></p>

<p class=MsoBodyTextIndent>Файл *.<span lang=EN-US>ofasl</span> – аналог *.<span
lang=EN-US>dcu</span>. Могут размещаться в разных экзотических местах, см. эти
места при компиляции или ищите поиском по диску. </p>

<p class=MsoBodyTextIndent>Пакет – пространство имён (перечень имён, допустимых
в определённом контексте, который может меняться во время выполнения).</p>

<p class=MsoBodyTextIndent><span lang=EN-US>eval</span>-<span lang=EN-US>when</span>
– аналог {$<span lang=EN-US>if</span><span lang=EN-US> </span>файлКомпилируется}
... {$<span lang=EN-US>elseif</span><span lang=EN-US> </span>файлЗагружается}
... {$<span lang=EN-US>endif</span>}, позволяет выполнять тот или иной код на
этапе компиляции и/или загрузки уже скомпилированного файла. </p>

<p class=MsoBodyTextIndent>#. – позволяет выполнять код в момент чтения текста
программы из файла (до компиляции).</p>

<p class=MsoBodyTextIndent><span lang=EN-US>asdf</span>-система – аналог файла
проекта или <span lang=EN-US>makefile</span>. Типичная программа содержит
множество взаимосвязанных систем <span lang=EN-US>asdf</span>, каждая из
которых имеет свой каталог и определение в файле *.<span lang=EN-US>asd</span>.
</p>

<p class=MsoBodyTextIndent>Динамическая разработка – возможность менять код
программы без её остановки. </p>

<p class=MsoBodyTextIndent style='text-indent:0cm'><span class=2><span
style='font-size:14.0pt'>&nbsp;</span></span></p>

<p class=MsoBodyTextIndent style='text-indent:0cm'><a name="_Toc345240542"><span
class=2><span style='font-size:14.0pt'>Таблица аналогий</span></span></a></p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>Delphi</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>CL</span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-size:10.0pt;font-family:"Courier New"'>*</span><span
  lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>.dpr</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span style='font-size:10.0pt'>Скрипт загрузки, с помощью которого
  «голая» лисп-система превращается в программу (мы ещё не рассматриваем </span><span
  lang=EN-US style='font-size:10.0pt'>save</span><span style='font-size:10.0pt'>-</span><span
  lang=EN-US style='font-size:10.0pt'>image</span><span style='font-size:10.0pt'>,
  но это в другой раз). Содержит инструкции по компиляции и загрузке всей
  системы. </span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>unit</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span style='font-size:10.0pt'>1. </span><span lang=EN-US
  style='font-size:10.0pt'>unit</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span style='font-size:10.0pt'>как единица сборки – файл, включённого
  в </span><span lang=EN-US style='font-size:10.0pt'>asdf</span><span
  style='font-size:10.0pt'>-систему или просто загружаемого из скрипта загрузки.
  </span></p>
  <p class=a><span style='font-size:10.0pt'>2. </span><span lang=EN-US
  style='font-size:10.0pt'>unit</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span style='font-size:10.0pt'>как пространство имён – пакет</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>interface,
  implementation</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span lang=EN-US style='font-size:10.0pt'>interface</span><span
  style='font-size:10.0pt'> - внешние символы пакета (обычно – в файле каталогСистемы/</span><span
  lang=EN-US style='font-size:10.0pt'>package</span><span style='font-size:
  10.0pt'>.</span><span lang=EN-US style='font-size:10.0pt'>lisp</span><span
  style='font-size:10.0pt'>, иногда – в файле исходного текста, форма </span><span
  lang=EN-US style='font-size:10.0pt;color:red'>defpackage</span><span
  style='font-size:10.0pt'>, </span><span lang=EN-US style='font-size:10.0pt;
  color:blue'>def</span><span style='font-size:10.0pt;color:blue'>-</span><span
  lang=EN-US style='font-size:10.0pt;color:blue'>merge</span><span
  style='font-size:10.0pt;color:blue'>-</span><span lang=EN-US
  style='font-size:10.0pt;color:blue'>packages</span><span style='font-size:
  10.0pt;color:blue'>::!</span><span style='font-size:10.0pt'>). Перечислены
  только имена сущностей, но не их типы.</span></p>
  <p class=a><span style='font-size:10.0pt'>Сами сущности (функции, макросы,
  типы, переменные) определены в исходном тексте без разбивки на </span><span
  lang=EN-US style='font-size:10.0pt'>interface</span><span lang=EN-US
  style='font-size:10.0pt'> </span><span style='font-size:10.0pt'>и </span><span
  lang=EN-US style='font-size:10.0pt'>implementation</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>uses</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span style='font-size:10.0pt'>Если рассматривать </span><span
  lang=EN-US style='font-size:10.0pt'>unit</span><span lang=EN-US
  style='font-size:10.0pt'> </span><span style='font-size:10.0pt'>как единицу
  сборки, то зависимости указываются в </span><span lang=EN-US
  style='font-size:10.0pt'>asdf</span><span lang=EN-US style='font-size:10.0pt'>
  </span><span style='font-size:10.0pt'>– системе. При неправильном порядке
  сборки, как правило, будут ошибки или предупреждения, а в худшем случае –
  молчаливая неправильная работа. </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>Если рассматривать </span><span
  lang=EN-US style='font-size:10.0pt'>unit</span><span lang=EN-US
  style='font-size:10.0pt'> </span><span style='font-size:10.0pt'>как набор
  допустимых имён, то зависимости указываются в форме определения пакета (:</span><span
  lang=EN-US style='font-size:10.0pt'>use</span><span style='font-size:10.0pt'>,
  :</span><span lang=EN-US style='font-size:10.0pt'>import</span><span
  style='font-size:10.0pt'>-</span><span lang=EN-US style='font-size:10.0pt'>from</span><span
  style='font-size:10.0pt'>). Но можно и без этого вызывать функцию из другого
  пространства имён с помощью префикса, главное, что символ должен существовать
  на момент чтения файла</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>initialization</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span style='font-size:10.0pt'>Любые формы, записанные в исходном
  тексте файла .</span><span lang=EN-US style='font-size:10.0pt'>lisp</span><span
  style='font-size:10.0pt'>, выполняются во время загрузки (за исключением </span><span
  lang=EN-US style='font-size:10.0pt'>eval</span><span style='font-size:10.0pt'>-</span><span
  lang=EN-US style='font-size:10.0pt'>when</span><span style='font-size:10.0pt'>).</span></p>
  <p class=a><span style='font-size:10.0pt'>Даже определение функции является
  не просто декларацией, а командой лисп-системе «в момент загрузки создай
  такую-то функцию». </span></p>
  <p class=a><span style='font-size:10.0pt'>&nbsp;</span></p>
  <p class=a><span style='font-size:10.0pt'>Нужно учитывать, что в Дельфи
  сначала компилируется вся программа, а только потом запускается </span><span
  lang=EN-US style='font-size:10.0pt'>initialization</span><span lang=EN-US
  style='font-size:10.0pt'> </span><span style='font-size:10.0pt'>первого
  модуля. В Лиспе, как правило, порядок действий другой: компиляция </span><span
  lang=EN-US style='font-size:10.0pt'>f</span><span style='font-size:10.0pt'>1.</span><span
  lang=EN-US style='font-size:10.0pt'>lisp</span><span style='font-size:10.0pt'>
  (если он требует перекомпиляции) – загрузка </span><span lang=EN-US
  style='font-size:10.0pt'>f</span><span style='font-size:10.0pt'>1.</span><span
  lang=EN-US style='font-size:10.0pt'>ofasl</span><span style='font-size:10.0pt'>,
  компиляция </span><span lang=EN-US style='font-size:10.0pt'>f</span><span
  style='font-size:10.0pt'>2.</span><span lang=EN-US style='font-size:10.0pt'>lisp</span><span
  style='font-size:10.0pt'>, загрузка </span><span lang=EN-US style='font-size:
  10.0pt'>f</span><span style='font-size:10.0pt'>2.</span><span lang=EN-US
  style='font-size:10.0pt'>ofasl</span><span style='font-size:10.0pt'> и т.п. При
  этом, для компиляции </span><span lang=EN-US style='font-size:10.0pt'>f</span><span
  style='font-size:10.0pt'>2.</span><span lang=EN-US style='font-size:10.0pt'>lisp</span><span
  lang=EN-US style='font-size:10.0pt'> </span><span style='font-size:10.0pt'>могут
  использоваться символы, функции и данные, определённые в </span><span
  lang=EN-US style='font-size:10.0pt'>f</span><span style='font-size:10.0pt'>1.</span><span
  lang=EN-US style='font-size:10.0pt'>lisp</span><span style='font-size:10.0pt'>.
  Про функции из </span><span lang=EN-US style='font-size:10.0pt'>f</span><span
  style='font-size:10.0pt'>3.</span><span lang=EN-US style='font-size:10.0pt'>lisp</span><span
  lang=EN-US style='font-size:10.0pt'> </span><span style='font-size:10.0pt'>система
  ещё и не подозревает.</span></p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-size:10.0pt;font-family:"Courier New"'>finalization</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=a><span style='font-size:10.0pt'>отсутствует, хотя можно задавать
  действия на уровне системы при выгрузке с помощью lispworks:define-action</span></p>
  </td>
 </tr>
</table>

<h3><a name="_Toc345240543">Что должно входить в файл *.</a><span lang=EN-US>lisp</span></h3>

<p class=MsoBodyTextIndent>В файле <b>*.</b><b><span lang=EN-US>lisp</span><span
lang=EN-US> </span></b>обязательно должна быть (в начале) форма (<span
lang=EN-US>in</span>-<span lang=EN-US>package</span> :имяПространстваИмён),
которая задаёт пространство имён этого файла. Само пространство имён может быть
определено в другом месте, но иногда оно определяется в самом файле. Тогда
форма (<span lang=EN-US>in</span>-<span lang=EN-US>package</span> ...) должна
идти после определения пакета, а само определение рекомендуется делать с
помощью <span lang=EN-US style='color:blue'>def</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>merge</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>packages</span><span style='color:blue'>::!</span>
с :<span lang=EN-US>always</span><span lang=EN-US> </span><span lang=EN-US>t</span>.
</p>

<p class=MsoBodyTextIndent><span style='color:blue'>Также</span><span
style='color:blue'> </span><span style='color:blue'>должна</span><span
style='color:blue'> </span><span style='color:blue'>быть</span><span
style='color:blue'> </span><span style='color:blue'>форма</span><span
lang=EN-US style='color:blue'> (in-readtable :buddens-readtable-a), </span><span
style='color:blue'>причём</span><span lang=EN-US style='color:blue'>, </span><span
style='color:blue'>символ</span><span lang=EN-US style='color:blue'>
EDITOR-HINTS.NAMED-READTABLES:IN-READTABLE) </span><span style='color:blue'>должен</span><span
style='color:blue'> </span><span style='color:blue'>быть</span><span
style='color:blue'> </span><span style='color:blue'>доступен</span><span
style='color:blue'> </span><span style='color:blue'>в</span><span
style='color:blue'> </span><span style='color:blue'>данном</span><span
style='color:blue'> </span><span style='color:blue'>пространстве</span><span
style='color:blue'> </span><span style='color:blue'>имён</span><span
lang=EN-US style='color:blue'>. </span></p>

<p class=MsoBodyTextIndent>Во время чтения файла при компиляции могут возникать
новые символы. Такие символы будут добавляться в заданный пакет в качестве
внутренних (неэкспортированных). </p>

<p class=MsoBodyTextIndent>Файл *.<span lang=EN-US>asd</span><span lang=EN-US> </span>здесь
не описан, см. примеры. </p>

<h2><a name="_Toc345240544">Динамическая разработка, основные сценарии</a></h2>

<p class=MsoBodyTextIndent>Динамическая разработка есть в <span lang=EN-US>SQL</span>
(<span lang=EN-US>create</span>/<span lang=EN-US>alter</span>/<span lang=EN-US>drop</span><span
lang=EN-US> </span><span lang=EN-US>table</span>, <span lang=EN-US>procedure</span><span
lang=EN-US> </span>и т.п.). В Лиспе она по сути, такая же по смыслу – можно
менять отдельные объекты. </p>

<h3><a name="_Toc345240545">Работа</a> в <span lang=EN-US style='color:red'>listener</span><span
lang=EN-US> (REPL)</span></h3>

<p class=MsoBodyTextIndent>В <span lang=EN-US>listener</span><span lang=EN-US> </span>можно
выполнять практически любые действия, например, создавать и вызывать функции,
определять классы, изучать данные. Последнее возвращённое выражение в листенере
печатает, далее можно нажать на микроскоп (<span lang=EN-US>Inspect</span>) и
просмотреть внутреннюю структуру объекта, это особенно важно для классов,
содержимое которых не видно на печати. </p>

<h3><a name="_Toc345240546">Разработка по одной форме в файле</a></h3>

<p class=MsoBodyTextIndent>В <span lang=EN-US>listener</span><span lang=EN-US> </span>хорошо
отлаживать фрагменты программы и программировать факториалы. При
&quot;настоящем&quot; программировании, для нового логически связанного
фрагмента программы сразу создают новый файл. Файл сначала создаётся согласно
пункту «что должно входить в файл *.<span lang=EN-US>lisp</span>», см. чуть
выше. Далее в него вносят определения функций и с помощью команды <span
lang=EN-US>Compile</span><span lang=EN-US> </span><span lang=EN-US>defun</span>
(<span lang=EN-US>f</span>7) компилируют их по одному. Смотрят на
предупреждения. Каждое определение можно проверить в листенере, при этом
желательно предварительно сделать в нём команду (<span lang=EN-US>in</span>-<span
lang=EN-US>package</span><span lang=EN-US> </span>:тотЖеПакет), чтобы было меньше
путаницы. При перекомпиляции сущности ведут себя так:</p>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>Сущность</p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>Как ведёт себя</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>функция (<span lang=EN-US>defun)</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>сразу вступает в действие.
  Все другие функции будут вызывать её. Если функция находится на стеке,
  продолжит выполняться старое тело до выхода. Рекурсивные вызовы будут
  вызывать новое тело. Но! Всё это может не работать при включенных
  оптимизациях. </p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>глобальная переменная 1 (<span
  lang=EN-US>defparameter)</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>присваивается новое
  значение</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>глобальная переменная 2 (<span
  lang=EN-US>defvar)</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>если переменная уже была
  переменной, заданной с помощью <span lang=EN-US>defvar</span>, НЕ
  присваивается новое значение, выдаётся предупреждение</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'><span lang=EN-US>defconstant</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>лучше так не делать. Если
  очень надо, сделать <span lang=EN-US>unintern</span> символу из всех пакетов,
  а затем перекомпилировать весь зависимый код</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'><span lang=EN-US>defstruct</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>действует новое
  определение. Экземпляры протухают</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'><span lang=EN-US>defclass</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>действует новое
  определение. Экземпляры остаются с новым определением, но конструктор не
  вызывается заново. </p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'><span lang=EN-US>defmacro</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>действует новое
  определение, но ранее скомпилированный код, в котором используется этот
  макрос, не меняется. Нужно его перекомпилировать.</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'><span lang=EN-US>deftype</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>не знаю. Безопасным будет
  перекомпилировать зависимый код</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'><span lang=EN-US>def</span>ЧтоТо</p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>Любой человек может
  создать своё <span lang=EN-US>def</span>ЧтоТо, см. определение этого <span
  lang=EN-US>def</span>ЧтоТо</p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>пространство имён <span
  lang=EN-US>defpackage</span></p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>сразу вступает в действие
  новое определение. Старые внутренние символы остаются на месте. </p>
  </td>
 </tr>
 <tr>
  <td width=493 valign=top style='width:369.65pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>система <span lang=EN-US>asdf</span>
  (<span lang=EN-US>defsystem</span>) </p>
  </td>
  <td width=493 valign=top style='width:369.65pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoBodyTextIndent style='text-indent:0cm'>её не надо
  перекомпилировать. Вместо этого попробуйте её перезагрузить (см. мануал <span
  lang=EN-US>asdf</span><span lang=EN-US> </span>или просто <span lang=EN-US>asdf</span>::!
  ), внимательно глядя на <span style='color:red'>*</span><span lang=EN-US
  style='color:red'>standard</span><span style='color:red'>-</span><span
  lang=EN-US style='color:red'>output</span><span style='color:red'>*</span> В
  сложных случаях проще всего стереть все *.<span lang=EN-US>ofasl</span><span
  lang=EN-US> </span>и перезапустить лисп-систему.</p>
  </td>
 </tr>
</table>

<p class=MsoBodyTextIndent>&nbsp;</p>

<h3><a name="_Toc345240547">Перекомпиляция файла целиком</a></h3>

<p class=MsoBodyTextIndent>Тоже вполне допустимая практика, если меняли в
нескольких местах. Она покажет такие ошибки, как неверно закрытые скобки и дважды
определённую в одном файле функцию или переменную. В случае ошибки чтения можно
попробовать в отладчике написать <span style='color:blue'>:</span><span
lang=EN-US style='color:blue'>e</span><span style='color:blue'> &lt;</span><span
lang=EN-US style='color:blue'>Enter</span><span style='color:blue'>&gt;</span>,
окрестности ошибки раскрасятся в разные цвета. Также можно щелкать на ворнинги
какой-то кнопкой мыши и, если повезёт, получится увидеть исходник. </p>

<h3><a name="_Toc345240548">Подводные камни динамической разработки и как их обойти</a></h3>

<p class=MsoBodyTextIndent>Только один пример. Мы писали функци <span
lang=EN-US>bar</span>, к-рая ссылается на функцию <span lang=EN-US>foo</span>. Потом
решили переименовать функцию <span lang=EN-US>foo</span>, взяли её определение,
поменяли в ней имя <span lang=EN-US>foo</span><span lang=EN-US> </span>на
нормальноеИмя и перекомпилировали. Всё хорошо, но функция <span lang=EN-US>foo</span><span
lang=EN-US> </span>тоже существует в пространстве имён, и при перекомпиляции
функции <span lang=EN-US>bar</span><span lang=EN-US> </span>никто нам не
скажет, что она всё ещё ссылается на <span lang=EN-US>foo</span>, а не на
нормальноеИмя. </p>

<p class=MsoBodyTextIndent>Существует множество других подводных камней
подобного рода, связанных с динамической природой лиспа. </p>

<p class=MsoBodyTextIndent>Не буду объяснять их все, но вот рекомендации: </p>

<p class=MsoBodyTextIndent>1. Макросы, типы данных и глобальные переменные
лучше выделить в отдельный файл, примерно так же, как это делается в <span
lang=EN-US>C</span>. </p>

<p class=MsoBodyTextIndent>2. Желательно дробить программу на как можно более
мелкие пакеты, для этого нужно пользоваться <span lang=EN-US style='color:blue'>def</span><span
style='color:blue'>-</span><span lang=EN-US style='color:blue'>merge</span><span
style='color:blue'>-</span><span lang=EN-US style='color:blue'>packages</span><span
style='color:blue'>::! </span>, т.к. у <span lang=EN-US>defpackage</span><span
lang=EN-US> </span>хватает граблей, связанных с одноимёнными экспортируемыми
символами в разных пакетах и др. </p>

<p class=MsoBodyTextIndent>3. Нужно стараться удалять сущности, которые
потеряли значение. Используйте для этого (<span lang=EN-US>unintern</span><span
lang=EN-US> </span>'<span lang=EN-US>foo</span>), а затем перекомпилируйте все
определения.</p>

<p class=MsoBodyTextIndent>4. В процессе интенсивной разработки, нужно
периодически удалять пакет, находящийся в разработке (сначала нужно выйти из
него в <span lang=EN-US>listener</span>-е и закрыть файл), после чего
перекомпилировать все файлы фрагмента. Это не получится сделать, если на данный
пакет уже ссылаются другие, в этом случае см. следующую рекомендацию. </p>

<p class=MsoBodyTextIndent>5. Также нужно периодически удалять все <span
lang=EN-US>ofasl</span><span lang=EN-US> </span>- файлы, созданные системой
(нужно иметь функцию или <span lang=EN-US>bat</span>-файл, к-рый это делает) и
запускать полную пересборку системы. </p>

<p class=MsoBodyTextIndent>6. <span lang=EN-US>asdf</span><span lang=EN-US> </span>работает
очень плохо (вроде 2-я версия стала лучше, но точно не знаю). Не полагайтесь на
задание зависимостей внутри системы, используйте в системе ключ :<span
lang=EN-US>serial</span>, а также есть <span lang=EN-US style='color:blue'>asdf</span><span
style='color:blue'>::</span><span lang=EN-US style='color:blue'>undefsystem</span>
, который сбрасывает кеш <span lang=EN-US>asdf</span><span lang=EN-US> </span>для
данной системы и который всегда лучше вызвать, если что-то серьёзно поменялось.
</p>

<h1><a name="_Toc345240549">Встроенные типы данных: символы, списки, массивы,
хеш-таблицы</a></h1>

<h1><a name="_Toc345240550">Полиморфные (родовые) функции, структуры и классы</a></h1>

<h2><a name="_Toc345240551">Родовые функции</a></h2>

<p class=MsoNormal>В Дельфи есть виртуальные функции. Такая функция объявляется
в одном (базовом) классе и может перекрываться для его наследников. </p>

<p class=MsoNormal>В зависимости от типа объекта, для которого вызывается
функция, будет реально исполнен разный код. </p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Также в <span lang=EN-US>Delphi</span> есть перегруженные (<span
lang=EN-US>overload</span>) функции, которые исполняются по-разному в
зависимости от типов нескольких аргументов. </p>

<p class=MsoNormal>Но, в отличие от виртуальных функций, выбор той или иной из
набора перегруженных функций определяется типом переменной, а не типом объекта.
Если переменная имеет тип <span lang=EN-US>TObject</span>, а хранится в ней <span
lang=EN-US>TComponent</span>, то будет вызвана перегруженная функция для <span
lang=EN-US>TObject</span>.</p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>В Лиспе также есть полиморфные, или <span style='color:red'>родовые
функции. </span>Они похожи на перегруженные тем, что исполняемый код зависит от
типов всех параметров, и похожи на виртуальные функции тем, что тип параметра
определяется не по типам переменных, а по типам объектов, являющихся
фактическими параметрами, во время исполнения. Подобно виртуальным методам <span
lang=EN-US>Delphi</span>, где можно вызвать <span lang=EN-US>inherited</span>,
в Лиспе можно вызвать &quot;родительский&quot; метод с помощью <span
lang=EN-US>(<span style='color:red'>call-next-method</span>). </span></p>

<p class=MsoNormal>Поскольку код определяется типами нескольких параметров, а
классы имеют множественное наследование, в Лиспе нет однозначного понятия
&quot;родительский&quot;. Реально исполняемый код зависит от типов фактических
параметров по довольно сложному алгоритму. Полное описание алгоритма можно
найти в <span lang=EN-US><a
href="http://lisper.ru/pcl/object-reorientation-generic-functions">Practical Common
Lisp</a></span>. Мы рассмотрим только простые частные случаи. </p>

<h3><a name="_Toc345240552">Основные методы с одним типизированным параметром</a></h3>

<p class=MsoNormal>У методов может быть квалификатор, <span style='color:red'>основной
метод</span> – это метод, у которого нет квалификатора. Будем для простоты
считать, что для каждого метода функции задан тип только одного аргумента –
первого. Этот случай соответствует не перегруженному виртуальному методу в
Дельфи. Всё работает совершенно аналогично: вызывается метод самого класса или
метод ближайшего предка, а <span lang=EN-US>call</span>-<span lang=EN-US>next</span>-<span
lang=EN-US>metod</span> работает так же, как <span lang=EN-US>inherited</span>.
</p>

<h3><a name="_Toc345240553">Методы со спецификатором </a><span lang=EN-US>eql</span>
</h3>

<p class=MsoNormal>Вместо спецификации типа может быть задан спецификатор <span
lang=EN-US>sql</span>. Это позволяет определять метод не для типов, а для
индивидуальных объектов. </p>

<h3><a name="_Toc345240554">Методы</a><span lang=EN-US> before, after, around</span></h3>

<p class=MsoNormal>В Дельфи есть события <span lang=EN-US>beforeOpen</span>, <span
lang=EN-US>afterOpen</span> и т.п. В Лиспе эта возможность реализована на
уровне родовых функций. Можно задать метод с квалификаторами :<span lang=EN-US>before</span>,
:<span lang=EN-US>after</span>, :<span lang=EN-US>around</span>. Рассмотрим
случай функции с одним типизированным аргументом. Методы :<span lang=EN-US>around</span>
выполняются в порядке от частного – к общему, т.е. от <span lang=EN-US>eql</span>,
к классу объекта к предкам. При этом, если где-то не вызвать <span lang=EN-US>call</span>-<span
lang=EN-US>next</span>-<span lang=EN-US>method</span>, то выполнение более
&quot;общих&quot; методов (как обычных, так и <span lang=EN-US>before</span>,<span
lang=EN-US>after</span>,<span lang=EN-US>around</span>) не будет происходить. </p>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal>Методы :<span lang=EN-US>before</span> аналогичны событию <span
lang=EN-US>Before</span>... в Дельфи, они выполняются в порядке от частного к
общему, изнутри вызова <span lang=EN-US>around</span>, но до вызова
&quot;основных&quot; методов, <span lang=EN-US>call</span>-<span lang=EN-US>next</span>-<span
lang=EN-US>method</span> вызывать не нужно. Методы :<span lang=EN-US>after</span>
выполняются после основных, внутри <span lang=EN-US>around</span>, в порядке от
частного к общему. </p>

<h3><a name="_Toc345240555">Ложка дёгтя</a></h3>

<p class=MsoNormal>В родовой функции, все методы должны иметь одинаковую
сигнатуру (лямбда-лист). Это означает, что мы не можем завести одну родовую
функцию &quot;<span lang=EN-US>add</span>&quot; на всю систему. Нужно либо
размещать функции <span lang=EN-US>add</span> с разными сигнатурами в разных
пакетах и вызывать их с префиксами, либо называть их по-разному. </p>

<h2><a name="_Toc345240556">Структуры</a></h2>

<p class=MsoNormal>Структура по своим возможностям примерно соответствует
классу в <span lang=EN-US>Delphi</span>, если не считать свойств (<span
lang=EN-US>properties</span>) и ограничения доступа - этого в Лиспе нет. Пример
определения структуры с тремя полями:</p>

<p class=a>(<span lang=EN-US>defstruct</span><span lang=EN-US> </span><span
lang=EN-US>мояСтруктура поле1 поле2 поле3) </span></p>

<p class=MsoNormal>Для такой структуры будет автоматически сгенерирован
конструктор <span lang=EN-US>make</span>-мояСтруктура и три функции для доступа
к полям, мояСтруктура-поле1,2,3 от одного аргумента.</p>

<p class=MsoNormal>Можно задавать для структур типы полей.</p>

<p class=MsoNormal>Каждая структура является классом. Структура может
&quot;включать&quot; в себя другую структуру (родитель) с помощью опции :<span
lang=EN-US>include</span>, (см. помощь для <span lang=EN-US>defstruct</span>), тогда
она становится подклассом родителя в иерархии классов. Поскольку для структур
можно определять родовые функции, можно сделать вывод, что структуры+родовые
функции примерно соответствуют классам Дельфи. </p>

<h3><a name="_Toc345240557">Конструктор</a></h3>

<p class=MsoNormal>Структура пассивна, это - просто набор данных. У неё нет
конструктора, его нужно эмулировать вызовом какой-то функции, написанной
пользователем. </p>

<h3><a name="_Toc345240558">Деструктор</a></h3>

<p class=MsoNormal>Деструкторы в лиспе вообще не водятся. Хотя можно назначить
действие на сборку мусора, (<span lang=EN-US>hcl</span>:add<a
name=marker-1038990></a>-special-free-action), но неизвестно, когда это
действие будет осуществлено, и возможности этого действия весьма ограничены, т.к.
оно вызывается в очень специфических условиях. Поэтому, если объект должен быть
явно «удалён», например, закрыт поток, нужно добавить в объект поле,
характеризующее его состояние, в деструкторе закрывать то, что надо, затем
ставить в поле состояния признак, что объект «убит» и особым образом
обрабатывать такие «убитые» объекты. Действие при сборке мусора, по хорошему,
должно лишь проверять, что объект при сборке мусора был закрыт должным образом,
и сообщать об ошибочной ситуации, если что-то не так.</p>

<h3><a name="_Toc345240559">Ложка дёгтя</a></h3>

<p class=MsoNormal>При переопределении структуры все её экземпляры становятся
инвалидными. </p>

<h2><a name="_Toc345240560">Классы</a></h2>

<p class=MsoNormal>Классами автор пользуется мало. Основное их преимущество
перед структурами – их можно переопределять «на лету», так, что все экземпляры
сохраняются. Для классов доступно множественное наследование, могут быть
определены конструкторы. Для классов функция  печати по умолчанию очень убогая,
нужно пользоваться инспектором или писать нужную функцию. Недостатком классов
можно считать то, что в них все функции – родовые, что сказывается на
производительности. Синтаксис определения класса могуч и многословен.
Повторюсь, родовые функции можно определять не только над классами, но и над структурами
и встроенными типами, так что без классов можно обходиться в большом количестве
случаев. </p>

<h1><a name="_Toc345240561">Изучение исходного текста</a></h1>

<p class=MsoNormal>В загруженной программе, <span lang=EN-US>Alt</span>-. показывает
определение переменной, ф-ии, класса, родовой ф-ии, макроса и многих других
объектов. <span lang=EN-US>Works/Tools/System browser </span>показывает системы<span
lang=EN-US> (</span>в т<span lang=EN-US>.</span>ч<span lang=EN-US>. asdf).
Works</span>/<span lang=EN-US>Tools</span>/<span lang=EN-US>Symbol</span><span
lang=EN-US> </span><span lang=EN-US>browser</span><span lang=EN-US> </span>позволяет
искать символы по части названия (то же делает и <span lang=EN-US>apropos</span>).
</p>

<h1><a name="_Toc345240562">Отладка</a></h1>

<h2><a name="_Toc345240563">Виды интерактивных отладочных режимов</a></h2>

<p class=MsoNormal style='text-indent:18.0pt'>Их три: консольный отладчик,
графический отладчик (жук) и степпер. Консольный и графический отладчик
работают координированно над одним и тем же стеком, эта пара является основным
средством интерактивной отладки. Но никто не отменял логгирование как полезное
средство отладки. </p>

<h2><a name="_Toc345240564">Изучение состояния программы</a></h2>

<h3><a name="_Toc345240565">Настройка отображения кадров стека</a></h3>

<p class=MsoBodyTextIndent>В меню &quot;<span lang=EN-US>view</span>&quot; жука
можно выбрать отображение тех или иных кадров стека. По умолчанию отладчик
показывает лишь небольшую часть из них.</p>

<h3><a name="_Toc345240566">Инспектор</a></h3>

<p class=MsoBodyTextIndent>Инспектор аналогичен инспектору в <span lang=EN-US>Delphi</span>
- он позволяет ходить по внутренней структуре объекта. </p>

<p class=MsoBodyTextIndent>В нормальных условиях инспектор вызывается нажатием
иконки с микроскопом в листенере. В этом случае он показывает содержимое
последнего результата вычисления. В графическом отладчике - &quot;жуке&quot;
инспектор вызывается при двойном щелчке нажатии на любую переменную стека. Для
возврата на предыдущий уровень структуры есть кнопка &quot;назад&quot;, как в
веб-браузере. </p>

<h2><a name="_Toc345240567">Листенер во время отладки</a></h2>

<p class=MsoBodyTextIndent>Если Вы находитесь в отладчике (см. &quot;Отладчик
очень близко&quot;), то листенер позволяет делать вычисления в контексте
текущего кадра стека. Это аналогично окну <span lang=EN-US>Evaluate</span>/<span
lang=EN-US>Modify</span><span lang=EN-US> </span>в отладчике <span lang=EN-US>Delphi</span>,
но без присущих <span lang=EN-US>Delphi</span><span lang=EN-US> </span>ограничений.
Например, можно в отладчике определить новую функцию. Если в графическом
отладчике (&quot;жуке&quot;) Вы выделили одинарным щелчком другой кадр стека,
то будут видны переменные этого кадра и над ними можно будет делать вычисления.
Но пространство имён при этом не переключается, поэтому может понадобиться
писать префикс пространства имён перед пакетом. </p>

<p class=MsoBodyTextIndent>При пошаговом исполнении листенер тоже доступен, но
он какой-то странный и автор им почти не пользуется. Например, неясно, каков
текущий пакет. Научите. </p>

<h2><a name="_Toc345240568">Разновидности ошибок и их локализация</a></h2>

<p class=MsoBodyTextIndent>В Дельфи бывает два вида ошибок по времени их
возникновения - ошибки компиляции и ошибки исполнения. В <span lang=EN-US>CL</span>
жизненный цикл программы устроен гораздо сложнее, поэтому перечислим эти виды и
способы их локализации. Напомним порядок обработки каждого файла программы:
чтение-компиляция-загрузка компилированного кода-выполнение, причём эти фазы
могут происходить в разных образах Лисп-системы. </p>

<h3><a name="_Toc345240569">Ошибки чтения</a></h3>

<p class=MsoBodyTextIndent>Они возникают в функции <span lang=EN-US>read</span>.
Соответственно, если среда говорит об ошибке и неглубоко по стеку Вы видите
функцию <span lang=EN-US>read</span>, то это - ошибка чтения. В кадре стека
ошибки есть переменная <span lang=EN-US>system</span>::<span lang=EN-US>eargs</span>,
и в ней есть поток. Инспектируя поток, можно понять имя файла. Делая <span
lang=EN-US>read</span>-<span lang=EN-US>line</span> этому потоку, можно
попробовать прочитать продолжение файла после места ошибки. <span lang=EN-US
style='color:blue'>editor</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>budden</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>tools</span><span style='color:blue'>::</span><span
lang=EN-US style='color:blue'>edit</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>stream</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>position</span><span lang=EN-US style='color:
blue'> </span><span style='color:blue'>открывает файл в том месте, где чтение
прервалось. С таблицей чтения </span><span lang=EN-US style='color:blue'>buddens</span><span
style='color:blue'>-</span><span lang=EN-US style='color:blue'>readtable</span><span
style='color:blue'>-</span><span lang=EN-US style='color:blue'>a</span><span
lang=EN-US style='color:blue'> </span><span style='color:blue'>можно
использовать в отладчике команду :</span><span lang=EN-US style='color:blue'>e</span><span
lang=EN-US style='color:blue'> </span><span style='color:blue'>для вызова
специального просмотровщика ошибок чтения, к-рый раскрасит файл в цвета по
уровням вложенности. </span>Также можно заполнить файл отладочным выводом: #.(<span
lang=EN-US>print</span> &quot;уникальная метка&quot;) и методом половинного
деления найти место, в котором случилась ошибка. </p>

<h3><a name="_Toc345240570">Ошибки компиляции</a></h3>

<p class=MsoNormal>Во многих случаях среда (в консоли) предлагает <span
lang=EN-US>edit</span><span lang=EN-US> </span><span lang=EN-US>source</span><span
lang=EN-US> </span><span lang=EN-US>where</span><span lang=EN-US> </span><span
lang=EN-US>error</span><span lang=EN-US> </span><span lang=EN-US>occured</span>.
Также можно установить переменную *<span lang=EN-US>compile</span>-<span
lang=EN-US>print</span>* в <span lang=EN-US>t</span>,но это не поможет, если в
файле много форм, являющихся макросами, определёнными пользователем. В этом
случае, вместо имени функции, среда напечатает &quot;(<span lang=EN-US>top</span>-<span
lang=EN-US>level</span>-<span lang=EN-US>form</span><span lang=EN-US> </span><span
lang=EN-US>NNN</span>)&quot;. Можно попробовать установить трассировку на <span
lang=EN-US>compiler</span>::<span lang=EN-US>process</span>-<span lang=EN-US>form</span>.
Самый общий способ основан на отладочном выводе: локализуйте ошибку, расставляя
в файле формы верхнего уровня (eval-when (:compile-toplevel) (print &quot;уникальная
метка&quot;)).</p>

<h3><a name="_Toc345240571">Ошибки загрузки</a></h3>

<p class=MsoNormal>Аналогичным образом, можно искать ошибку с помощью расстановки
форм (eval-when (:<span lang=EN-US>load</span>-toplevel) (print &quot;уникальная
метка&quot;))</p>

<h2><a name="_Toc345240572">Трассировка</a></h2>

<p class=MsoNormal>Трассировка очень удобна, т.к. она показывает параметры и
возвращающие значения любого множества функций, отображая глубину вложенности
стека отступами. Можно трассировать обычную функцию, родовую функцию или её отдельные
методы, а также <span style='color:red'>макросы</span>. Для трассировки обычной
ф-ии пишем (<span lang=EN-US style='color:red'>trace</span><span lang=EN-US> </span>имя),
нажимаем <span lang=EN-US>ctrl</span>-<span lang=EN-US>alt</span>-<span
lang=EN-US>t</span><span lang=EN-US> </span>на её имени или выбираем
трассировку в контектном меню. Перекомпилировать функцию не нужно. Можно
делать  трассировку с (<span lang=EN-US style='color:red'>break</span>)  - в
этом случае исполнение прервётся при входе. Трассировку методов можно делать
через <span lang=EN-US>Works</span>/<span lang=EN-US>Tools</span>/<span
lang=EN-US>Generic</span><span lang=EN-US> </span><span lang=EN-US>function</span><span
lang=EN-US> </span><span lang=EN-US>browser</span>, выбирая методы и вызывая
для каждого из них контекстное меню. Для выключения трассировки всех функций выполняем
(<span lang=EN-US>untrace</span>). Аналогичным трассировке методом является
отладочная печать. <span lang=EN-US style='color:blue'>Show</span><span
style='color:blue'>-</span><span lang=EN-US style='color:blue'>expr</span><span
lang=EN-US style='color:blue'> </span>позволяет выводить само выражение и его
значение. </p>

<h2><a name="_Toc345240573">Остановы и пошаговое исполнение</a></h2>

<p class=MsoNormal>В коде можно ставить точки останова, нажав на красную кнопку
с кружком в начале формы, где хотим остановиться. Эта возможность запускает
пошаговый отладчик. Всё бы хорошо, но <span lang=EN-US>iterate</span> и <span
lang=EN-US style='color:blue'>proga</span><span lang=EN-US> </span>так меняют
код, что эта возможность становится почти везде недоступной - среда не умеет ставить
точки останова в коде, подвеграющемся макрорасширению. Поэтому основным
способом установки точки прерывания является вставка в нужное место кода вызова
(<span lang=EN-US style='color:red'>break</span>) <span lang=EN-US>c</span><span
lang=EN-US> </span>последующей перекомпиляцией функции. При таком способе
останова нельзя из режима останова перейти в режим пошагового исполнения.
Негусто, но радуемся тому, что не нужно перекомпилировать всё приложение
целиком. </p>

<h2><a name="_Toc345240574"><span lang=EN-US>Assert</span></a>, <span
lang=EN-US style='color:blue'>with</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>the</span><span style='color:blue'>1</span></h2>

<p class=MsoNormal><span lang=EN-US style='color:red'>Assert</span><span
lang=EN-US> </span>означает то же, что в <span lang=EN-US>Delphi</span><span
lang=EN-US> </span>и им нужно пользоваться как можно более интенсивно. <span
lang=EN-US style='color:blue'>With</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>the</span><span style='color:blue'>1</span> сочетает
в себе связывание локальной переменной, декларацию типа и его проверку. </p>

<h2><a name="_Toc345240575"><span lang=EN-US>Unit</span></a>-тестирование</h2>

<p class=MsoNormal><span lang=EN-US>Unit</span>-тестирование в лиспе не
составляет затруднений благодаря его устройству. Автор пользуется собственным
(очень легковесным) средством определения тестов, <span lang=EN-US
style='color:blue'>def</span><span style='color:blue'>-</span><span lang=EN-US
style='color:blue'>trivial</span><span style='color:blue'>-</span><span
lang=EN-US style='color:blue'>test</span><span style='color:blue'>::! </span>В
серьёзных системах тесты размещаются в отдельных <span lang=EN-US>asdf</span>-системах,
но автор обычно разрабатывает код стремительно и для экономии сил помещает
тесты прямо в исходные тексты; тесты выполняются во время загрузки. Заодно
тесты служат примерами использования кода.</p>

<h2><a name="_Toc345240576">Профайлер</a></h2>

<p class=MsoNormal>Он есть в <span lang=EN-US>Lispworks</span>.</p>

<h1><a name="_Toc345240577"><span lang=EN-US>eval</span><span lang=EN-US> </span>и
макросы</a></h1>

<h2><a name="_Toc345240578"><span lang=EN-US>Eval</span></a></h2>

<p class=MsoNormal><span lang=EN-US>Eval</span><span lang=EN-US> </span>предназначен
для динамической генерации и выполнения кода во время выполнения программы. Он
аналогичен командам <span lang=EN-US>SQL</span>: <span lang=EN-US>execute</span><span
lang=EN-US> </span><span lang=EN-US>statement</span>, <span lang=EN-US>exec</span>,
<span lang=EN-US>sp</span>_<span lang=EN-US>execute</span>_<span lang=EN-US>sql</span><span
lang=EN-US> </span>и т.п. Общий смысл - код составляется и выполнятся во время
выполнения. Разница между <span lang=EN-US>SQL</span><span lang=EN-US> </span>и
Лиспом состоит в том, что в <span lang=EN-US>SQL</span><span lang=EN-US> </span>складывются
строки, а в <span lang=EN-US>Lisp</span> происходит обработка деревьев. При
этом часто используется <span style='color:red'>квазицитирование</span>. </p>

<p class=MsoNormal><span lang=EN-US>Eval</span><span lang=EN-US> </span>снижает
производительность и делает программу менее надёжной, поэтому его можно
использовать только там, где это необходимо.</p>

<h2><a name="_Toc345240579">Макросы</a></h2>

<p class=MsoNormal><span style='color:red'>Макросы</span> аналогичны <span
lang=EN-US>Eval</span>, но генерация кода происходит не во время выполнения, а
во время компиляции. Соответственно, при расширении макроса доступна та
инфраструктура, которая имеется во время компиляции. В частности, неизвестны
конкретные значения переменных. Сгенерированный код (дерево) подставляется
вместо &quot;вызова&quot; макроса в код и далее полученный результат
компилируется. Также макросы в чём-то аналогичны #<span lang=EN-US>define</span><span
lang=EN-US> </span>из С, но их возможности несравнимо шире, т.к. при расширении
макроса можно делать произвольные вычисления, они могут быть рекурсивными,
обращаться к внешнему миру и т.п. При определении макросов обычно используется <span
style='color:red'>квазицитирование</span>. </p>

<h3><a name="_Toc345240580">Преимущества</a></h3>

<p class=MsoNormal>Фактически, макросы делают компилятор расширяемым, что
является уникальным свойством <span lang=EN-US>Common</span><span lang=EN-US> </span><span
lang=EN-US>Lisp</span>. Проекты типа <span lang=EN-US>opencxx</span><span
lang=EN-US> </span>или <span lang=EN-US>Nemerle</span><span lang=EN-US> </span>являются
лишь приближением к этому идеалу, который реализован в Лиспе просто и
элегантно. Макросы совместимы с компиляцией и не наносят ущерба производительности,
в отличие от <span lang=EN-US>eval</span>.</p>

<h3><a name="_Toc345240581">Недостатки</a></h3>

<p class=MsoNormal>Макросы затрудняют или делают невозможной пошаговую отладку.
Иногда нелегко найти и ошибку в исходном тексте, полученном в резлультате
макрорасширения (для этого нужно использовать <span lang=EN-US
style='color:red'>macroexpand</span><span lang=EN-US style='color:red'> </span>или
трассировать макрос). При изменении определения макроса, функции, в которых он
используется, не меняются. Чтобы изменение макроса подействовало на функцию, где
он вызывается, нужно перекомпилировать </p>

<p class=MsoNormal>эту функцию.</p>

<p class=MsoPlainText>&nbsp;</p>

</div>

</body>

</html>

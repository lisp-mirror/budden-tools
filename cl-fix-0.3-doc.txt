This library contains: 

- per-package package nicknames,
for (at least) Lispworks, Allegro, CCL, CLISP and SBCL. 

- def-symbol-readmacro. Usually you assign readmacros
to characters. But there are just too few characters. 
Now you can assign readmacros to symbols, too, so there
is an unlimited space for making your DSLs with custom
syntax.

- def-merge-packages::!
resolve some kinds of symbol clashes 
automatically. There are two policies, 
one is safer (import neither of clashing 
symbols), other is "denser" (import first 
of them). This small macro in conjunction
with readtable extensions simplifies 
a task of managing multiple small 
packages and thus helps improve modularity

- "advanced" readtable case:
You can assign "advanced" readtable-case to 
your readtable so that:
(read-from-string "sym") is SYM
(read-from-string "SYM") is SYM
but
(read-from-string "CamelCase") is |CamelCase|)
see budden-tools::readtable-case-advanced
There are some caveats with keywords and a bug
with uninterned symbols. 

- forbidden symbol names. You can explicitly
state that some symbol name is forbidden in a package.
After that, reader errs when that symbol is attempted
to be read into the package.

- interning to another package with package::symbol
can be forbidden

- custom token parsers. Run your code
when reader finds "PACKAGE-QUALIFIER:" in 
a stream. 

- proga. Get rid of some 
parens and nestings. Instead
of
 
(let ((a b))
 (flet ((f (x) y))
  (with-open-file (f "v" ...)
   (f a))

write just

(proga
 (let a b)
 (flet f (x) y)
 (with-open-file f "v" ...)
 (f a))

which is easier to read and
write (when you get used to it). 

- iterate-keywords (need to be 
downloaded from http://sourceforge.net/projects/iteratekeywords/
)
now you need to import just only
one symbol to use iterate in 
your package. Use keywords as clause heads. 
(iter (:for ...)) 

